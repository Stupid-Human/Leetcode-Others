刷题记录

### Pro

> **应该尽可能多的看各种各样的题目，思考五分钟，想不出来解法的话直接看别人的答案**。看懂思路就行了，甚至自己写一遍都没必要，因为比较浪费时间。
>
> 笔试的时候最怕的是没思路，所以把各种题型都过目一下，起码心里不会慌，只要有思路，平均一道题二三十分钟搞定还是不难的。
>
> 没有什么问题是暴力穷举解决不了的，直接用 [回溯算法套路框架](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect) 硬上，大不了加个备忘录，不就成 [动态规划套路框架](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect) 了么，再大不了这题我不做了么，暴力过上 60% 的 case 也挺 OK 的。



电子书网站：https://labuladong.gitbook.io/algo/

[小白入门计划](https://mp.weixin.qq.com/s/xD73QztJyckefNxLmzzHNA)

[进阶修炼计划](https://mp.weixin.qq.com/s/YM_lryU1DlDLweO8PRQsYw)

[突击笔试计划](https://mp.weixin.qq.com/s/SZoTG4DFfhQgc4LbhwyjKw)



所以，先把小白系列全看了（链表相关、二叉树系列(已经OK))，其次是二分搜索技巧，再次才是动态规划，最后回溯算法登场



**pass**（完成列表）

第0章

​	~~我写了首诗，让你闭着眼睛也能写对二分搜索~~

第1章

​	~~双指针技巧总结~~

​	~~twoSum问题的核心思想~~

​	~~滑动窗口技巧~~

​	~~一文秒杀四道原地修改数组的算法题~~

​	~~[如何判断回文链表](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484822&idx=1&sn=44742c9a3557038c8da7150100d94db9&chksm=9bd7fb9eaca0728876e1146306a09f5453bcd5c35c4a264304ea6189faa83ec12a00322f0246&scene=21#wechat_redirect)~~

​	~~[O(1)时间删除/查找数组中的任意元素](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487414&idx=1&sn=2be87c0c9279da447f8ac8b8406230fe&chksm=9bd7f1beaca078a865357f58ba2ff12b46490b0a773c0221e0a846c67950fa9c661664ad500e&scene=21#wechat_redirect)~~

第4章 高频面试系列

​	~~洗牌算法详解：你会排序，但你会打乱吗？~~

​	~~随机算法之水塘抽样算法~~



每个系列都可以展开很多题目，先不要扩展这么多了，比如滑动窗口技巧，我就花了很多时间来做类似的题，好处是这个框架我真的能死死记住，坏处是导致进度变慢，其他类型的题刷不了，稍微取舍一下吧。



### 二叉树框架

参考文章：

[二叉树就那几个框架](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect)  

[手把手刷二叉树（第一期）](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487126&idx=1&sn=4de13e66397bc35970963c5a1330ce18&chksm=9bd7f09eaca0798853c41fba05ad5fa958b31054eba18b69c785ae92f4bd8e4cc7a2179d7838#rd) 

[手把手刷二叉树（第二期）](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487270&idx=1&sn=2f7ad74aabc88b53d94012ceccbe51be&chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9#rd) 

[手把手刷二叉树（第三期）](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487527&idx=1&sn=9cf2b0d8608ba26ea7c6a5c9b41d05a1&chksm=9bd7ee2faca0673916bf075539bf6fc3c01f3dcc0b298b3f507047692ef5c850ed9cfe82e4e6#rd)

[手把手刷二叉搜索树（第一期）](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488101&idx=1&sn=6041ddda5f20ccde8a7036d3e3a1482c&chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&token=1113604856&lang=zh_CN&scene=21#wechat_redirect)

[原创 | 手把手刷二叉搜索树（第二期）](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488128&idx=2&sn=b8fb3fd2917f9ac86127054741cd5877&chksm=9bd7ec88aca0659ee0185b657663169169493e9df2063fa4d28b38a0b4d0dd698d0301937898&scene=21#wechat_redirect)

[东哥手把手带你刷二叉树|第三期](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487527&idx=1&sn=9cf2b0d8608ba26ea7c6a5c9b41d05a1&chksm=9bd7ee2faca0673916bf075539bf6fc3c01f3dcc0b298b3f507047692ef5c850ed9cfe82e4e6&scene=21#wechat_redirect)





```
void traverse(TreeNode root){
	//前序遍历
	traverse(root.left);
	//中序遍历
	traverse(root.right);
	//后续遍历
}
```

> 只要涉及递归，都可以抽象成二叉树的问题。例如，*[**快速排序**](https://www.runoob.com/w3cnote/quick-sort.html)就是个二叉树的前序遍历，[**归并排序**](https://www.runoob.com/w3cnote/merge-sort.html)是后序遍历*

**写递归算法的关键是要明确递归函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归**。

二叉树的算法都是基于递归框架的，关键思路是要先考虑root需要做什么，然后剩下的事情抛给前/中/后序的遍历框架就行。

二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习。

> 递归debug
>
> **直接在递归函数内部打印关键值，配合缩进，直观地观察递归函数执行情况**。新定义一个函数 `printIndent` 和一个全局变量 `count`：
>
> ```
> // 全局变量，记录递归函数的递归层数
> int count = 0;
> 
> // 输入 n，打印 n 个 tab 缩进
> void printIndent(int n) {
>  for (int i = 0; i < n; i++) {
>      printf("   ");
>  }
> }
> ```
>
> **在递归函数的开头，调用 `printIndent(count++)` 并打印关键变量；然后在所有 `return` 语句之前调用 `printIndent(--count)` 并打印返回值**。



#### [1-10]

- [**226. 翻转二叉树**](https://leetcode-cn.com/problems/invert-binary-tree/)

- ^^[**116. 填充每个节点的下一个右侧节点指针**](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

- ^^[**114. 二叉树展开为链表**](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

- ^^[**206. 反转链表**](https://leetcode-cn.com/problems/reverse-linked-list/)

- ^^[**反转链表的前N个节点**](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484467&idx=1&sn=beb3ae89993b812eeaa6bbdeda63c494&chksm=9bd7fa3baca0732dc3f9ae9202ecaf5c925b4048514eeca6ac81bc340930a82fc62bb67681fa&scene=21#wechat_redirect)

- ^^[**92. 反转链表 II**](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

- ^^[**25. K 个一组翻转链表**](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

- [**654. 最大二叉树**](https://leetcode-cn.com/problems/maximum-binary-tree/)


- [**105. 从前序与中序遍历序列构造二叉树**](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [**297. 二叉树的序列化与反序列化**](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)



**226**

> **二叉树的一个问题难点在于，如何把题目的要求细化成每个节点需要做的事情。**
>
> 本题，前序遍历，后续遍历均可，中序遍历不行。

**116**

> [完美二叉树](https://www.cnblogs.com/idorax/p/6441043.html)，一个深度为k(>=-**1**)且有2^(k+1) - 1个结点的二叉树称为**完美二叉树**，就是国内翻译为“满二叉树”的二叉树，满了。**完全二叉树**从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充。**完满二叉树**所有非叶子结点的度都是2。
>
> 增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」。

**114**

> 判定条件之前的赋值，TreeNode tmp = root就是对的，TreeNode tmp = root.right; 这样写就是错的，奇妙。

**206**

> **对于递归算法，最重要的就是明确递归函数的定义**。

> 两个地方需要注意：
>
> **1、递归函数要有 base case**，也就是这句：
>
> ```
> if (head.next == null) return head;
> ```
>
> **2、当链表递归反转之后，新的头节点是`last`，而之前的`head`变成了最后一个节点，别忘了链表的末尾要指向 null**
>
> 此外，空链表要单独考虑。

> 迭代算法，注意节点、循环结束的条件。

**反转链表的前N个节点**

> 递归实现

```
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
} 
```

**92**

> [即反转单链表的一部分](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484467&idx=1&sn=beb3ae89993b812eeaa6bbdeda63c494&chksm=9bd7fa3baca0732dc3f9ae9202ecaf5c925b4048514eeca6ac81bc340930a82fc62bb67681fa&scene=21#wechat_redirect)。	

**654**

> **想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可**。

**297**

> [labuladong解法](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect)  重新做一遍，如果要自己设计接口，真的很不好搞。
>
> 一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 `node` 列表包含空指针的信息，所以只使用 `node` 列表就可以还原二叉树。

**插曲**

> 以后用python3来实现
>
> 面向对象是以功能来划分问题，而不是步骤。面向对象 v.s. 面向过程。
>
> **对象是对客观事物的抽象，类是对对象的抽象**。类是一种抽象的数据类型。它们的关系是，对象是类的实例，类是对象的模板。
>
> 类：具有属性和方法。
>
> 类 v.s. 实例：创建实例是通过类名+()实现的，创建实例的时候，`__init__`方法可把`name`，`score`等属性绑上去，`self`表示创建的实例本身。类中定义的函数第一个参数永远是实例变量`self`，并且调用时不用传递该参数。
>
> 数据封装。
>
> 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`
>
> 当我们定义一个class的时候，可以从某个现有的class**继承**，新的class称为子类，被继承的称为父类。多态，指的是，子类的方法覆盖了父类的方法，代码运行的时候总是会调用子类的方法。 



#### [11-15]

- [**106. 从中序与后序遍历序列构造二叉树**](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

- [**652. 寻找重复的子树**](https://leetcode-cn.com/problems/find-duplicate-subtrees/)
- [**230. 二叉搜索树中第K小的元素**](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

- [**538. 把二叉搜索树转换为累加树**](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)  1038与该题相同

- [**96. 不同的二叉搜索树**](https://leetcode-cn.com/problems/unique-binary-search-trees/)



到图了。。。先不看了



**BST（二叉搜索树）**

>1、对于 BST 的每一个节点`node`，左子树节点的值都比`node`的值要小，右子树节点的值都比`node`的值大。
>
>2、对于 BST 的每一个节点`node`，它的左侧子树和右侧子树都是 BST。
>
>它构建起了数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。
>
>**BST 的中序遍历结果是有序的（升序）**。把递归顺序改下(先递归右子树再递归左子树)就是降序了。
>
>BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是`O(logN)`的复杂度。
>
>BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求。

**230** 

> 可以把每个节点添加额外信息——以该节点为根的子树的节点数目，这样可以实现O(logN)的时间复杂度，而不是O(N)的时间复杂度。

**BST 的基础操作**

> 判断 BST 的合法性
>
> ```
> boolean isValidBST(TreeNode root) {
>  return isValidBST(root, null, null);
> }
> 
> /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
> boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
>  // base case
>  if (root == null) return true;
>  // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
>  if (min != null && root.val <= min.val) return false;
>  if (max != null && root.val >= max.val) return false;
>  // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
>  return isValidBST(root.left, min, root) 
>      && isValidBST(root.right, root, max);
> }
> ```
>
> **通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧**
>
> 在 BST 中搜索一个数
>
> ```
> boolean isInBST(TreeNode root, int target) {
>  if (root == null) return false;
>  if (root.val == target)
>      return true;
>  if (root.val < target) 
>      return isInBST(root.right, target);
>  if (root.val > target)
>      return isInBST(root.left, target);
>  // root 该做的事做完了，顺带把框架也完成了，妙
> }
> ```
>
> **针对 BST 的遍历框架**
>
> ```
> void BST(TreeNode root, int target) {
>  if (root.val == target)
>      // 找到目标，做点什么
>  if (root.val < target) 
>      BST(root.right, target);
>  if (root.val > target)
>      BST(root.left, target);
> }
> ```
>
> 在 BST 中插入一个数
>
> BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。**一旦涉及「改」，函数就要返回`TreeNode`类型，并且对递归调用的返回值进行接收**。
>
> ```
> TreeNode insertIntoBST(TreeNode root, int val) {
>  // 找到空位置插入新节点
>  if (root == null) return new TreeNode(val);
>  // if (root.val == val)
>  //     BST 中一般不会插入已存在元素
>  if (root.val < val) 
>      root.right = insertIntoBST(root.right, val);
>  if (root.val > val) 
>      root.left = insertIntoBST(root.left, val);
>  return root;
> }
> ```
>
> 在 BST 中删除一个数
>
> ```
> TreeNode deleteNode(TreeNode root, int key) {
>  if (root.val == key) {
>      // 找到啦，进行删除
>  } else if (root.val > key) {
>      // 去左子树找
>      root.left = deleteNode(root.left, key);
>  } else if (root.val < key) {
>      // 去右子树找
>      root.right = deleteNode(root.right, key);
>  }
>  return root;
> }
> ```
>
> 分三种情况
>
> 如果待删除的节点(假设为A)恰好是末端节点，两个子节点都为空，那么它可以当场去世了
>
> ```
> if (root.left == null && root.right == null)
>  return null;
> ```
>
> A只有一个非空子节点，那么它要让这个孩子接替自己的位置。
>
> ```
> // 排除了情况 1 之后
> if (root.left == null) return root.right;
> if (root.right == null) return root.left;
> ```
>
> A有两个子节点，麻烦了，为了不破坏 BST 的性质，`A`必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。
>
> ```
> if (root.left != null && root.right != null) {
>  // 找到右子树的最小节点
>  TreeNode minNode = getMin(root.right);
>  // 把 root 改成 minNode
>  root.val = minNode.val;
>  // 转而去删除 minNode
>  root.right = deleteNode(root.right, minNode.val);
> }
> ```
>
> 整合
>
> ```
> TreeNode deleteNode(TreeNode root, int key) {
>  if (root == null) return null;
>  if (root.val == key) {
>      // 这两个 if 把情况 1 和 2 都正确处理了
>      if (root.left == null) return root.right;
>      if (root.right == null) return root.left;
>      // 处理情况 3
>      TreeNode minNode = getMin(root.right);
>      root.val = minNode.val;
>      root.right = deleteNode(root.right, minNode.val);
>  } else if (root.val > key) {
>      root.left = deleteNode(root.left, key);
>  } else if (root.val < key) {
>      root.right = deleteNode(root.right, key);
>  }
>  return root;
> }
> 
> TreeNode getMin(TreeNode node) {
>  // BST 最左边的就是最小的
>  while (node.left != null) node = node.left;
>  return node;
> } 
> ```
>
> 这个删除操作并不完美，因为我们一般不会通过`root.val = minNode.val`修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换`root`和`minNode`两个节点。因为具体应用中，`val`域可能会是一个复杂的数据结构，修改起来非常麻烦；而链表操作无非改一改指针，而不会去碰内部数据。但暂时忽略这个细节了。

**96**

> 不可以直接暴力递归，应该用备忘录来辅助查询。

**图**

>```
>/* 多叉树遍历框架 */
>void traverse(TreeNode root) {
>if (root == null) return;
>
>for (TreeNode child : root.children)
>   traverse(child);
>}
>```

>图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。所以图的遍历框架就要一个 `visited` 数组进行辅助：
>
>```
>Graph graph;
>boolean[] visited;
>
>/* 图遍历框架 */
>void traverse(Graph graph, int s) {
>if (visited[s]) return;
>// 经过节点 s
>visited[s] = true;
>for (TreeNode neighbor : graph.neighbors(s))
>   traverse(neighbor);
>// 离开节点 s
>visited[s] = false;   
>}
>```
>
>





### 回溯算法框架

参考链接：[回溯算法解题套路框架](https://labuladong.gitbook.io/algo/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban)

回溯算法其实就是我们常说的 DFS (深度优先搜索)算法，本质上就是一种暴力穷举算法，**纯暴力穷举，复杂度一般都很高**，而动态规划存在重叠子问题可以优化。

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

> 1、路径：也就是已经做出的选择。
>
> 2、选择列表：也就是你当前可以做的选择。
>
> 3、结束条件：也就是到达决策树底层，无法再做选择的条件。

算法框架：**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**，特别简单。

**全排列代码**

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**各种搜索问题其实都是树的遍历问题**，而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点：**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行**。

「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：进入之前做选择，离开之后撤销选择。**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

#### [16-17]

- [**46. 全排列**](https://leetcode-cn.com/problems/permutations/)

- [**51. N 皇后**](https://leetcode-cn.com/problems/n-queens/)  ★★★



### 链表相关

- [**206. 反转链表**](https://leetcode-cn.com/problems/reverse-linked-list/)  Python3重新实现
- [**92. 反转链表 II**](https://leetcode-cn.com/problems/reverse-linked-list-ii/) Python3重新实现
- [**25. K 个一组翻转链表**](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
- [**704. 二分查找**](https://leetcode-cn.com/problems/binary-search/)

- [**34. 在排序数组中查找元素的第一个和最后一个位置**](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

- [**1004. 最大连续1的个数 III**](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)  和424类似，暂时不做了

- [**234. 回文链表**](https://leetcode-cn.com/problems/palindrome-linked-list/)

- 

涉及链表的递归操作——206  92  25

链表是一种兼具递归和迭代性质的数据结构

#### 二分查找框架

[二分搜索](https://labuladong.gitbook.io/algo/mu-lu-ye/er-fen-cha-zhao-xiang-jie)  原文有详细的解释

**思路很简单，细节是魔鬼**。

真正的坑根本在于到底要给 `mid` 加一还是减一，while 里到底用 `<=` 还是 `<`。

**寻找一个数（基本的二分搜索）的二分查找框架**

>```
>int binarySearch(int[] nums, int target) {
>    int left = 0, right = ...;
>
>    while(...) {
>        int mid = left + (right - left) / 2;
>        if (nums[mid] == target) {
>            ...
>        } else if (nums[mid] < target) {
>            left = ...
>        } else if (nums[mid] > target) {
>            right = ...
>        }
>    }
>    return ...;
>}
>```
>
>**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。`...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。计算 mid 时需要防止溢出，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大直接相加导致溢出。
>
>代码如下：
>
>```
>int binarySearch(int[] nums, int target) {
>    int left = 0; 
>    int right = nums.length - 1; // 注意
>
>    while(left <= right) {
>        int mid = left + (right - left) / 2;
>        if(nums[mid] == target)
>            return mid; 
>        else if (nums[mid] < target)
>            left = mid + 1; // 注意
>        else if (nums[mid] > target)
>            right = mid - 1; // 注意
>    }
>    return -1;
>}
>
>因为我们初始化 right = nums.length - 1
>所以决定了我们的「搜索区间」是 [left, right]
>所以决定了 while (left <= right)
>同时也决定了 left = mid+1 和 right = mid-1
>
>因为我们只需找到一个 target 的索引即可
>所以当 nums[mid] == target 时可以立即返回
>```

**寻找左侧边界的二分搜索**

> **框架**
>
> ```
> int left_bound(int[] nums, int target) {
>     int left = 0, right = nums.length - 1;
>     // 搜索区间为 [left, right]
>     while (left <= right) {
>         int mid = left + (right - left) / 2;
>         if (nums[mid] < target) {
>             // 搜索区间变为 [mid+1, right]
>             left = mid + 1;
>         } else if (nums[mid] > target) {
>             // 搜索区间变为 [left, mid-1]
>             right = mid - 1;
>         } else if (nums[mid] == target) {
>             // 收缩右侧边界
>             right = mid - 1;
>         }
>     }
>     // 检查出界情况
>     if (left >= nums.length || nums[left] != target)
>         return -1;
>     return left;
> }
> ```

**寻找右侧边界的二分搜索**

> **框架**
>
> ```
> int right_bound(int[] nums, int target) {
>     int left = 0, right = nums.length - 1;
>     while (left <= right) {
>         int mid = left + (right - left) / 2;
>         if (nums[mid] < target) {
>             left = mid + 1;
>         } else if (nums[mid] > target) {
>             right = mid - 1;
>         } else if (nums[mid] == target) {
>             // 这里改成收缩左侧边界即可
>             left = mid + 1;
>         }
>     }
>     // 这里改为检查 right 越界的情况，见下图
>     if (right < 0 || nums[right] != target)
>         return -1;
>     return right;
> }
> ```

**建议将「搜索区间」统一成两端都闭!!! 好记~**

**总结：**

>1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。
>
>2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。
>
>3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 `nums[mid] == target` 时做修改即可，搜索右侧时需要减一。
>
>4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 `nums[mid] == target` 条件处的代码和返回的逻辑即可，**推荐拿小本本记下，作为二分搜索模板**。

**704**

> **多种解法囊括了全部，直接看leetcode提交记录即可**





#### 回文链表

回文串就是正着读和反着读都一样的字符串。回文串的的长度可能是奇数，也可能是偶数，解决该类问题的核心是**双指针**

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串**。

```
string palindrome(string& s, int l, int r) {
    // 防止索引越界
    while (l >= 0 && r < s.size()
            && s[l] == s[r]) {
        // 向两边展开
        l--; r++;
    }
    // 返回以 s[l] 和 s[r] 为中心的最长回文串
    return s.substr(l + 1, r - l - 1);
}
```

因为回文串长度可能为奇数也可能是偶数，长度为奇数时只存在一个中心点，而长度为偶数时存在两个中心点，所以上面这个函数需要传入`l`和`r`，就是为了处理这两种情况。

**判断一个字符串是不是回文串就简单很多，不需要考虑奇偶情况，只需要「双指针技巧」，从两端向中间逼近即可**

> ```
>bool isPalindrome(string s) {
>  int left = 0, right = s.length - 1;
>  while (left < right) {
>         if (s[left] != s[right])
>             return false;
>         left++; right--;
>     }
>     return true;
>    }
>    ```
> 
> 单链表无法倒着遍历，无法使用双指针技巧。那么最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同，该方法pass，没做出来。

链表兼具递归结构，树结构不过是链表的衍生。那么，**链表其实也可以有前序遍历和后序遍历**：

```
void traverse(ListNode head) {
    // 前序遍历代码
    traverse(head.next);
    // 后序遍历代码
}
```

如果我想正序打印链表中的`val`值，可以在前序遍历位置写代码；反之，如果想倒序遍历链表，就可以在后序遍历位置操作：

```
/* 倒序打印单链表中的元素值 */
void traverse(ListNode head) {
    if (head == null) return;
    traverse(head.next);
    // 后序遍历代码
    print(head.val);
}
```

**234**

> 用快慢指针先找到中间节点，然后把右半部分反转，然后再逐一比较。

### 数组相关

- [**141. 环形链表**](https://leetcode-cn.com/problems/linked-list-cycle/)
- [**142. 环形链表 II**](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
- [**876. 链表的中间结点**](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
- [**19. 删除链表的倒数第 N 个结点**](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
- [**167. 两数之和 II - 输入有序数组**](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)
- [**344. 反转字符串**](https://leetcode-cn.com/problems/reverse-string/)
- 76~1004为滑动窗口系列
- [**76. 最小覆盖子串**](https://leetcode-cn.com/problems/minimum-window-substring/)
- [**567. 字符串的排列**](https://leetcode-cn.com/problems/permutation-in-string/)
- [**438. 找到字符串中所有字母异位词**](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)
- [**3. 无重复字符的最长子串**](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
- [**239. 滑动窗口最大值**](https://leetcode-cn.com/problems/sliding-window-maximum/)      用框架法没有做出来
- [**485. 最大连续 1 的个数**](https://leetcode-cn.com/problems/max-consecutive-ones/)
- [**1423. 可获得的最大点数**](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)
- [**剑指 Offer 48. 最长不含重复字符的子字符串**](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)   与3重复
- [**424. 替换后的最长重复字符**](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)    用框架法没有做出来
- [**209. 长度最小的子数组**](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
- [**1. 两数之和**](https://leetcode-cn.com/problems/two-sum/)





#### 双指针

[双指针技巧总结](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/shuang-zhi-zhen-ji-qiao)

> 我把双指针技巧再分为两类，一类是**「快慢指针」**，一类是**「左右指针」**。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

**快慢指针系列**

> 快慢指针一般都初始化指向链表的头结点 `head`，前进时快指针 `fast` 在前，慢指针 `slow` 在后，巧妙解决一些链表中的问题。

**141**

> 用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 `null`，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

**142**

>当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

**876**

> 让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。

> **寻找链表中点的一个重要作用是对链表进行归并排序。回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在你学会了找到链表的中点，就能实现链表的二分了。**

**19**

> 使用快慢指针，让快指针先走 `n` 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 `null` 时，慢指针所在的位置就是倒数第 `n` 个链表节点（`n` 不会超过链表长度）。

**左右指针系列**

> 左右指针在数组中实际是指两个索引值，一般初始化为 `left = 0, right = nums.length - 1`

- 二分查找（见前文）

- 两数之和  **167**   **只要数组有序，就应该想到双指针技巧**

- 反转数组  **344**
- 滑动窗口算法（见下文）    解决一大类子字符串匹配的问题



#### **双指针技巧秒杀四道数组/链表题目**





#### 滑动窗口

[滑动窗口技巧](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/hua-dong-chuang-kou-ji-qiao-jin-jie)

思路非常简单，就是维护一个窗口，不断滑动，然后更新答案，时间复杂度是 O(N)，比字符串暴力算法要高效得多。

**滑动窗口算法的思路**：

> 1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。
>
> 2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。
>
> 3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。
>
> 4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。
>
> 这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，**也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

**算法大致逻辑**：

```
int left = 0, right = 0;
while (right < s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;    
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

各种细节问题才是困扰之处，算法框架：

```
/* 滑动窗口算法框架 */

// needs 和 window 相当于计数器，分别记录串T中字符出现次数和「窗口」中的相应字符的出现次数
// valid 变量表示窗口中满足 need 条件的字符个数，如果 valid 和 need.size 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 T。


void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0;   
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

**其中两处** **`...`** **表示的更新窗口数据的地方，到时候你直接往里面填就行了**。这两个 `...` 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。这是**一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug**。

**套模板，只需要思考以下四个问题**：

1、当移动 `right` 扩大窗口，即加入字符时，应该更新哪些数据？

2、什么条件下，窗口应该暂停扩大，开始移动 `left` 缩小窗口？

3、当移动 `left` 缩小窗口，即移出字符时，应该更新哪些数据？

4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

如果一个字符进入窗口，应该增加 `window` 计数器；如果一个字符将移出窗口的时候，应该减少 `window` 计数器；当 `valid` 满足 `need` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。



**76**

```
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0;
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c])
                valid++;
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }                    
        }
    }
    // 返回最小覆盖子串
    return len == INT_MAX ?
        "" : s.substr(start, len);
}
```

**567**

> 对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：
>
> 1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，应为排列嘛，显然长度应该是一样的。
>
> 2、当发现 `valid == need.size()` 时，就说  明窗口中就是一个合法的排列，所以立即返回 `true`。
>
> 至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

```
// 判断 s 中是否存在 t 的排列
bool checkInclusion(string t, string s) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0;
    while (right < s.size()) {
        char c = s[right];
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c])
                valid++;
        }

        // 判断左侧窗口是否要收缩
        while (right - left >= t.size()) {
            // 在这里判断是否找到了合法的子串
            if (valid == need.size())
                return true;
            char d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }
        }
    }
    // 未找到符合条件的子串
    return false;
}
```

**438**

>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 `res` 即可。

**3**

> 连 `need` 和 `valid` 都不需要，而且更新窗口内数据也只需要简单的更新计数器 `window` 即可。
>
> 当 `window[c]` 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 `left` 缩小窗口了嘛。
>
> 唯一需要注意的是，在哪里更新结果 `res` 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？
>
> 这里和之前不一样，要在收缩窗口完成后更新 `res`，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。

**239**

> 框架法没有做出来，改日再试

**485**

> 框架法做出来了，yeah

**1423**

> 框架法做出来了，amazing。
>
> 反过来想，滑动窗口的大小为len(carPoints)-k，滑动窗口内的值的和取最小，那么剩下的牌的和就是最大的了。最后只需要用总和减掉这个最小和即为所求。缩减窗口时注意添加条件。

**剑指 Offer 48** pass 与leetcode3完全一样

**424**

> emmm......

**209**

> 和1423的思路有点点像，这些题目，总的来说，根据4个步骤，就能够想清楚了。
>
> 不会做的几道题，以后再搞吧。



####  Two Sum 系列

问题的**最基本形式**

> 给你一个数组和一个整数`target`，可以保证数组中**存在**两个数的和为`target`，请你返回这两个数的索引。
>
> **Two Sum 系列问题就是想教我们如何使用哈希表处理问题**
>
> 问题的关键在于是无序的，如果是有序，那么用双指针解决比较合适。

**1**

> 用上述方法来做即可。











### 其他/高频面试系列

- [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

- [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

- [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)





#### **随机算法之水塘抽样算法**

> 问题的难点在于，随机选择是「动态」的，比如说你现在你有 5 个元素，你已经随机选取了其中的某个元素`a`作为结果，但是现在再给你一个新元素`b`，你应该留着`a`还是将`b`作为结果呢，以什么逻辑选择`a`和`b`呢，怎么证明你的选择方法在概率上是公平的呢？

> 结论：**当你遇到第`i`个元素时，应该有`1/i`的概率选择该元素，`1 - 1/i`的概率保持原有的选择****。**

每次以`1/i`的概率更新结果就可以保证结果是平均随机

```
/* 返回链表中一个随机节点的值 */
int getRandom(ListNode head) {
    Random r = new Random();
    int i = 0, res = 0;
    ListNode p = head;
    // while 循环遍历链表
    while (p != null) {
        // 生成一个 [0, i) 之间的整数
        // 这个整数等于 0 的概率就是 1/i
        if (r.nextInt(++i) == 0) {
            res = p.val;
        }
        p = p.next;
    }
    return res;
}
```

**同理，如果要随机选择`k`个数，只要在第`i`个元素处以`k/i`的概率选择该元素，以`1 - k/i`的概率保持原有选择即可**。

```
/* 返回链表中 k 个随机节点的值 */
int[] getRandom(ListNode head, int k) {
    Random r = new Random();
    int[] res = new int[k];
    ListNode p = head;

    // 前 k 个元素先默认选上
    for (int j = 0; j < k && p != null; j++) {
        res[j] = p.val;
        p = p.next;
    }

    int i = k;
    // while 循环遍历链表
    while (p != null) {
        // 生成一个 [0, i) 之间的整数
        int j = r.nextInt(++i);
        // 这个整数小于 k 的概率就是 k/i
        if (j < k) {
            res[j] = p.val;
        }
        p = p.next;
    }
    return res;
}
```

**382**

**398**

#### 洗牌算法/随机乱置算法

目标——打乱一个数组，洗牌算法都是靠随机选取元素交换来获取随机性

我们面临两个问题：

1. 什么叫做「真的乱」？

2. 设计怎样的算法来打乱数组才能做到「真的乱」？**分析洗牌算法正确性的准则：产生的结果必须有 n! 种可能，否则就是错误的。**

**384**

> 如上。





